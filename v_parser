import re

LABEL_MAP = {
    "Type of Inspection":        "type_of_inspection",
    "SAP Notification Number":   "sap_notification_number",
    "SAP Order #":               "sap_order_number",
    "Problem Statement":         "problem_statement",
    "Reported By":               "reported_by",
    "Reporter's Email":          "reporter_email",
    "Reporter's Contact Number": "reporter_contact_number",
    "Reporter's Full Name":      "reporter_full_name",
    "Type of Employee":          "employee_type",
    "Company Name":              "company_name",
    "Created At":                "created_at",
    "District Number":           "district_number",
    "High Fire":                 "high_fire",
    "How P1 was Identified":     "how_p1_identified",
    "CIP":                       "cip",
    "Address":                   "address",
    "Circuit Voltage":           "circuit_voltage",
    "Floc":                      "floc",
    "SFloc":                     "sfloc",
    "Circuit Name":              "circuit_name",
    "Longitude":                 "longitude",
    "Latitude":                  "latitude",
    "WorkOrderNumber":           "work_order_number",
    "Comments":                  "comments",
}

MAILTO_RE = re.compile(r"<mailto:[^>]+>", flags=re.IGNORECASE)

def clean_value(v: str) -> str:
    """
    Remove Outlook 'mailto:' junk and trim whitespace.
    """
    if not v:
        return None
    v = MAILTO_RE.sub("", v).strip()
    return v if v else None


def parse_p1_form_from_body(body: str) -> dict:
    """
    Supports:
    - "Field: value"
    - "Field:\nvalue"
    - multiline Comments
    - ignores photos/URLs entirely
    """
    result = {v: None for v in LABEL_MAP.values()}

    # Restrict to form section
    header = "OVERHEAD DETAIL INSPECTION P1 FORM"
    idx = body.find(header)
    if idx != -1:
        body = body[idx + len(header):]

    lines = [ln.rstrip() for ln in body.splitlines()]

    current_key = None
    waiting_for_value = None

    for line in lines:
        stripped = line.strip()
        if not stripped:
            continue

        # Case 1: Label:   (value missing, next line contains value)
        if stripped.endswith(":"):
            label_name = stripped[:-1].strip()
            if label_name in LABEL_MAP:
                waiting_for_value = LABEL_MAP[label_name]
                current_key = waiting_for_value
            continue

        # Case 2: Label: value  (same line)
        if ":" in stripped:
            label_raw, value_raw = stripped.split(":", 1)
            label = label_raw.strip()
            value = clean_value(value_raw.strip())

            if label in LABEL_MAP:
                key = LABEL_MAP[label]
                result[key] = value
                current_key = key
                waiting_for_value = None
                continue

        # Case 3: This line is the value for a previous "Label:\n"
        if waiting_for_value:
            result[waiting_for_value] = clean_value(stripped)
            current_key = waiting_for_value
            waiting_for_value = None
            continue

        # Case 4: Continuation line (only really matters for Comments)
        if current_key:
            existing = result.get(current_key) or ""
            result[current_key] = (existing + " " + stripped).strip()

    return result



############## IDENTIFYING ORDER 
from collections import defaultdict

threads = defaultdict(list)

# Group by thread
for row in rows:
    cid = row["conversation_id"]
    threads[cid].append(row)

# Analyze each thread
final = []

for cid, msgs in threads.items():
    # Sort by conversation index length (shortest = origin)
    msgs_sorted = sorted(msgs, key=lambda x: len(x["conversation_index"] or ""))

    # Tag them
    for i, msg in enumerate(msgs_sorted):
        msg["reply_order"] = i
        msg["is_origin"] = (i == 0)

        final.append(msg)



## Datetime safe
from datetime import datetime
from zoneinfo import ZoneInfo

PACIFIC = ZoneInfo("America/Los_Angeles")

def safe_datetime(dt_obj):
    """
    Convert Outlook/pywintypes datetime to a timezone-aware
    Python datetime in California time (America/Los_Angeles).
    Returns None if dt_obj is missing or invalid.
    """
    if dt_obj is None:
        return None

    try:
        # pywintypes.datetime usually behaves like a naive local datetime
        if dt_obj.tzinfo is None:
            # Treat it as local Pacific time and attach tzinfo
            return datetime(
                dt_obj.year,
                dt_obj.month,
                dt_obj.day,
                dt_obj.hour,
                dt_obj.minute,
                dt_obj.second,
                getattr(dt_obj, "microsecond", 0),
                tzinfo=PACIFIC,
            )
        else:
            # If it already has tzinfo, convert to Pacific
            return dt_obj.astimezone(PACIFIC)
    except Exception:
        return None



## Extract thread text
import re

def extract_reply_text(body: str) -> str:
    """
    Extract just the human reply at the top of an Outlook message body,
    stopping when we hit quoted history or the P1 form header.
    """
    if not body:
        return ""

    lines = body.splitlines()
    cleaned = []

    for line in lines:
        stripped = line.strip()
        upper = stripped.upper()

        # allow blank lines inside reply
        if not stripped:
            cleaned.append(line)
            continue

        # Stop when quoted thread or form begins
        if upper.startswith("FROM:"):
            break
        if upper.startswith("SENT:"):
            break
        if upper.startswith("TO:"):
            break
        if upper.startswith("SUBJECT:"):
            break
        if "OVERHEAD DETAIL INSPECTION P1 FORM" in stripped:
            break
        if stripped.startswith("-----Original Message-----"):
            break
        if stripped.startswith("____________________________"):
            break
        if stripped.endswith("WROTE:"):
            break
        if stripped.startswith(">"):  # quoted style
            break
        if "GET OUTLOOK FOR IOS" in upper or "GET OUTLOOK FOR ANDROID" in upper:
            break

        cleaned.append(line)

    return "\n".join(cleaned).strip()


## final origin dataset
from collections import defaultdict
import pandas as pd

origin_rows = []

for cid, msgs in threads.items():
    # Sort so origin is first, replies follow in true order
    msgs_sorted = sorted(
        msgs,
        key=lambda x: (
            len(x["conversation_index"] or ""),
            x["conversation_index"]
        )
    )

    origin = msgs_sorted[0]
    replies = msgs_sorted[1:]

    # Parse the P1 form from the origin *only*
    parsed_form = parse_p1_form_from_body(origin["body"])

    thread_length = len(msgs_sorted)
    num_replies = max(thread_length - 1, 0)

    # ----- first reply (if any) -----
    first_reply_time = None
    first_reply_sender = None
    first_reply_email = None
    first_reply_text = None

    if replies:
        first = replies[0]
        first_reply_time = first["received_time"]
        first_reply_sender = first["sender"]
        first_reply_email = first["sender_email"]
        first_reply_text = extract_reply_text(first["body"])

    # ----- all replies stitched together (for ML / context) -----
    all_reply_chunks = []
    for r in replies:
        txt = extract_reply_text(r["body"])
        if not txt:
            continue

        stamp = r["received_time"]
        chunk_header = f"[reply_order={r.get('reply_order', '?')} sender={r['sender']} time={stamp}]"
        chunk = f"{chunk_header}\n{txt}"
        all_reply_chunks.append(chunk)

    # You asked about separators: I recommend a visual separator with newlines,
    # it's easier for you to read *and* fine for ML.
    all_replies_text = "\n\n---\n\n".join(all_reply_chunks) if all_reply_chunks else None

    origin_record = {
        # Thread / origin metadata
        "conversation_id": cid,
        "entry_id": origin["entry_id"],
        "received_time": origin["received_time"],
        "subject": origin["subject"],
        "sender": origin["sender"],
        "sender_email": origin["sender_email"],
        "thread_length": thread_length,
        "num_replies": num_replies,

        # Reply summary
        "first_reply_time": first_reply_time,
        "first_reply_sender": first_reply_sender,
        "first_reply_email": first_reply_email,
        "first_reply_text": first_reply_text,
        "all_replies_text": all_replies_text,

        # Parsed P1 form fields (all the structured stuff)
        **parsed_form,
    }

    origin_rows.append(origin_record)

origin_df = pd.DataFrame(origin_rows)
origin_df.to_csv("p1_incidents_with_replies.csv", index=False)
print("Saved p1_incidents_with_replies.csv with", len(origin_df), "rows")

### extraction helper
import re

def extract_reply_text(body: str) -> str:
    """
    Extract just the human reply at the top of an Outlook message body,
    stopping when we hit quoted history or the P1 form header.
    """
    if not body:
        return ""

    lines = body.splitlines()
    cleaned = []

    for line in lines:
        stripped = line.strip()
        upper = stripped.upper()

        # allow blank lines inside reply
        if not stripped:
            cleaned.append(line)
            continue

        # Stop when quoted thread or form begins
        if upper.startswith("FROM:"):
            break
        if upper.startswith("SENT:"):
            break
        if upper.startswith("TO:"):
            break
        if upper.startswith("SUBJECT:"):
            break
        if "OVERHEAD DETAIL INSPECTION P1 FORM" in stripped:
            break
        if stripped.startswith("-----Original Message-----"):
            break
        if stripped.startswith("____________________________"):
            break
        if stripped.endswith("WROTE:"):
            break
        if stripped.startswith(">"):  # quoted style
            break
        if "GET OUTLOOK FOR IOS" in upper or "GET OUTLOOK FOR ANDROID" in upper:
            break

        cleaned.append(line)

    return "\n".join(cleaned).strip()


## build origin with all reply info 
from collections import defaultdict
import pandas as pd

origin_rows = []

for cid, msgs in threads.items():
    # Sort so origin is first, replies follow in true order
    msgs_sorted = sorted(
        msgs,
        key=lambda x: (
            len(x["conversation_index"] or ""),
            x["conversation_index"]
        )
    )

    origin = msgs_sorted[0]
    replies = msgs_sorted[1:]

    # Parse the P1 form from the origin *only*
    parsed_form = parse_p1_form_from_body(origin["body"])

    thread_length = len(msgs_sorted)
    num_replies = max(thread_length - 1, 0)

    # ----- first reply (if any) -----
    first_reply_time = None
    first_reply_sender = None
    first_reply_email = None
    first_reply_text = None

    if replies:
        first = replies[0]
        first_reply_time = first["received_time"]
        first_reply_sender = first["sender"]
        first_reply_email = first["sender_email"]
        first_reply_text = extract_reply_text(first["body"])

    # ----- all replies stitched together (for ML / context) -----
    all_reply_chunks = []
    for r in replies:
        txt = extract_reply_text(r["body"])
        if not txt:
            continue

        stamp = r["received_time"]
        chunk_header = f"[reply_order={r.get('reply_order', '?')} sender={r['sender']} time={stamp}]"
        chunk = f"{chunk_header}\n{txt}"
        all_reply_chunks.append(chunk)

    # You asked about separators: I recommend a visual separator with newlines,
    # it's easier for you to read *and* fine for ML.
    all_replies_text = "\n\n---\n\n".join(all_reply_chunks) if all_reply_chunks else None

    origin_record = {
        # Thread / origin metadata
        "conversation_id": cid,
        "entry_id": origin["entry_id"],
        "received_time": origin["received_time"],
        "subject": origin["subject"],
        "sender": origin["sender"],
        "sender_email": origin["sender_email"],
        "thread_length": thread_length,
        "num_replies": num_replies,

        # Reply summary
        "first_reply_time": first_reply_time,
        "first_reply_sender": first_reply_sender,
        "first_reply_email": first_reply_email,
        "first_reply_text": first_reply_text,
        "all_replies_text": all_replies_text,

        # Parsed P1 form fields (all the structured stuff)
        **parsed_form,
    }

    origin_rows.append(origin_record)

origin_df = pd.DataFrame(origin_rows)
origin_df.to_csv("p1_incidents_with_replies.csv", index=False)
print("Saved p1_incidents_with_replies.csv with", len(origin_df), "rows")



## cleaning form comments

import re

PHOTO_DOMAIN = r"scempstalsesa001pidmz\.blob\.core\.windows\.net/notification-photos"

def clean_comments(raw: str | None) -> str | None:
    if not raw or not isinstance(raw, str):
        return raw

    txt = raw

    # 1) If there's a "Photos:" section, chop everything from there down
    if "Photos:" in txt:
        txt = txt.split("Photos:", 1)[0]

    # 2) Just in case, strip any remaining blob URLs
    txt = re.sub(
        rf"https?://{PHOTO_DOMAIN}[^\s>]*",
        "",
        txt,
        flags=re.IGNORECASE,
    )

    # 3) Remove "Download Photo" labels
    txt = re.sub(r"\bDownload Photo\b", "", txt, flags=re.IGNORECASE)

    # 4) Collapse extra whitespace / blank lines
    txt = re.sub(r"[ \t]{2,}", " ", txt)
    txt = re.sub(r"\n{2,}", "\n", txt)

    txt = txt.strip()
    return txt or None

origin_df["comments"] = origin_df["comments"].apply(clean_comments)
