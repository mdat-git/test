import re

LABEL_MAP = {
    "Type of Inspection":        "type_of_inspection",
    "SAP Notification Number":   "sap_notification_number",
    "SAP Order #":               "sap_order_number",
    "Problem Statement":         "problem_statement",
    "Reported By":               "reported_by",
    "Reporter's Email":          "reporter_email",
    "Reporter's Contact Number": "reporter_contact_number",
    "Reporter's Full Name":      "reporter_full_name",
    "Type of Employee":          "employee_type",
    "Company Name":              "company_name",
    "Created At":                "created_at",
    "District Number":           "district_number",
    "High Fire":                 "high_fire",
    "How P1 was Identified":     "how_p1_identified",
    "CIP":                       "cip",
    "Address":                   "address",
    "Circuit Voltage":           "circuit_voltage",
    "Floc":                      "floc",
    "SFloc":                     "sfloc",
    "Circuit Name":              "circuit_name",
    "Longitude":                 "longitude",
    "Latitude":                  "latitude",
    "WorkOrderNumber":           "work_order_number",
    "Comments":                  "comments",
}

MAILTO_RE = re.compile(r"<mailto:[^>]+>", flags=re.IGNORECASE)

def clean_value(v: str) -> str:
    """
    Remove Outlook 'mailto:' junk and trim whitespace.
    """
    if not v:
        return None
    v = MAILTO_RE.sub("", v).strip()
    return v if v else None


def parse_p1_form_from_body(body: str) -> dict:
    """
    Supports:
    - "Field: value"
    - "Field:\nvalue"
    - multiline Comments
    - ignores photos/URLs entirely
    """
    result = {v: None for v in LABEL_MAP.values()}

    # Restrict to form section
    header = "OVERHEAD DETAIL INSPECTION P1 FORM"
    idx = body.find(header)
    if idx != -1:
        body = body[idx + len(header):]

    lines = [ln.rstrip() for ln in body.splitlines()]

    current_key = None
    waiting_for_value = None

    for line in lines:
        stripped = line.strip()
        if not stripped:
            continue

        # Case 1: Label:   (value missing, next line contains value)
        if stripped.endswith(":"):
            label_name = stripped[:-1].strip()
            if label_name in LABEL_MAP:
                waiting_for_value = LABEL_MAP[label_name]
                current_key = waiting_for_value
            continue

        # Case 2: Label: value  (same line)
        if ":" in stripped:
            label_raw, value_raw = stripped.split(":", 1)
            label = label_raw.strip()
            value = clean_value(value_raw.strip())

            if label in LABEL_MAP:
                key = LABEL_MAP[label]
                result[key] = value
                current_key = key
                waiting_for_value = None
                continue

        # Case 3: This line is the value for a previous "Label:\n"
        if waiting_for_value:
            result[waiting_for_value] = clean_value(stripped)
            current_key = waiting_for_value
            waiting_for_value = None
            continue

        # Case 4: Continuation line (only really matters for Comments)
        if current_key:
            existing = result.get(current_key) or ""
            result[current_key] = (existing + " " + stripped).strip()

    return result



############## IDENTIFYING ORDER 
from collections import defaultdict

threads = defaultdict(list)

# Group by thread
for row in rows:
    cid = row["conversation_id"]
    threads[cid].append(row)

# Analyze each thread
final = []

for cid, msgs in threads.items():
    # Sort by conversation index length (shortest = origin)
    msgs_sorted = sorted(msgs, key=lambda x: len(x["conversation_index"] or ""))

    # Tag them
    for i, msg in enumerate(msgs_sorted):
        msg["reply_order"] = i
        msg["is_origin"] = (i == 0)

        final.append(msg)
